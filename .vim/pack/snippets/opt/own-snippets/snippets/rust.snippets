snippet main
	pub fn main() {
	    ${0}
	}
snippet fn
	fn ${1:function_name}(${2}) ${3}{
	    ${0}
	}
snippet struct
	pub struct ${1:Struct} {
	    ${2}
	}

	impl ${1} {
	    pub fn new(${3}) -> Self {
	        ${1} {
	            ${0}
	        }
	    }
	}
snippet new
	pub fn new(${2}) -> ${1:Self} {
	    $1 {
	        ${0}
	    }
	}
snippet asref
	impl AsRef<${1:Ref}> for ${2:Type} {
	    fn as_ref(&self) -> &${3:$1} {
	        &self.${0:field}
	    }
	}
snippet asmut
	impl AsMut<${1:Ref}> for ${2:Type} {
	    fn as_mut(&mut self) -> &mut ${3:$1} {
	        &mut self.${0:field}
	    }
	}
snippet drop
	impl Drop for ${1:Struct} {
	    fn drop(&mut self) {
	        ${0}
	    }
	}
snippet impl
	impl ${1}${2: for $3} {
	    ${0}
	}
snippet enum
	enum ${1:Enum} {
	    ${0}
	}
snippet mod
	mod ${1:mod} {
	    ${0:$VISUAL}
	}
snippet trait
	trait ${1:Trait} {
	    ${0:$VISUAL}
	}
snippet for
	for ${1:i} in ${2:$3..$4} {
	    ${0}
	}
snippet foreach
	for ${1:(i, &item)} in ${2:iter${3:.enumerate()}} {
	    ${0}
	}
snippet iflet
	if let Some(${1}) = ${2} {
	    ${0:$VISUAL}
	}
snippet todo
	// TODO: ${0:$VISUAL}
snippet pr
	println!("${1}"${2});
snippet dump
	println!("{:#?}", ${1:$VISUAL});
snippet opt
	Option<${1:i32}>
snippet res
	Result<${1:&str}, ${2:()}>
snippet array
	let ${1:array} = vec![${2:0u8}; ${3:len}];
snippet vec
	let ${1:vec}: Vec<${2:u8}> = Vec::new();
snippet box
	Box::new(${0:$VISUAL})
snippet rc
	Rc::new(${0:$VISUAL})
snippet use
	use ${1:std::$2};
snippet crate
	extern crate ${1:sync};
snippet #[
	#[${1:derive}(${2:Debug})]
