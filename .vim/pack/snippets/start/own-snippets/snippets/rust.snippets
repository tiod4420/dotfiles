snippet {{
	{
	    ${0:$VISUAL}
	}
snippet <
	<${1:${VISUAL:T}}>
snippet fn
	fn ${1:function_name}(${2}) ${3:-> ${4:T} }{
	    ${0:$VISUAL}
	}
snippet struct
	struct ${1:Struct} {
	    ${0:$VISUAL}
	}
snippet enum
	enum ${1:Enum} {
	    ${0:$VISUAL}
	}
snippet impl
	impl ${1:${VISUAL:Struct}} {
	    ${0}
	}
snippet trait
	impl ${1:Trait} for ${2:${VISUAL:Struct}} {
	    ${0}
	}
snippet new
	pub fn new(${1}) -> Self {
	    Self {
	        ${0}
	    }
	}
snippet default
	impl Default for ${1:${VISUAL:Struct}} {
	    fn default() -> Self {
	        Self {
	            ${0}
	        }
	    }
	}
snippet drop
	impl Drop for ${1:${VISUAL:Struct}} {
	    fn drop(&mut self) {
	        ${0}
	    }
	}
snippet debug
	impl fmt::Debug for ${1:${VISUAL:Struct}} {
	    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
	        ${0:write!(fmt, "")}
	    }
	}
snippet display
	impl fmt::Display for ${1:${VISUAL:Struct}} {
	    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
	        ${0:write!(fmt, "")}
	    }
	}
snippet from
	impl From<${1:T}> for ${2:${VISUAL:Struct}} {
	    fn from(${3:from}: ${1}) -> Self {
	        ${0}
	    }
	}
snippet tryfrom
	impl TryFrom<${1:T}> for ${2:${VISUAL:Struct}} {
	    type Error = ${3:&'static str};

	    fn try_from(${4:from}: ${1}) -> Result<Self, Self::Error> {
	        ${0}
	    }
	}
snippet fromstr
	impl FromStr for ${1:${VISUAL:Struct}} {
	    type Err = ${2:&'static str};

	    fn from_str(s: &str) -> Result<Self, Self::Err> {
	        ${0}
	    }
	}
snippet asref
	impl AsRef<${1:T}> for ${2:${VISUAL:Struct}} {
	    fn as_ref(&self) -> &${1} {
	        ${0}
	    }
	}
snippet asmut
	impl AsMut<${1:T}> for ${2:${VISUAL:Struct}} {
	    fn as_mut(&mut self) -> &mut ${1} {
	        ${0}
	    }
	}
snippet deref
	impl ops::Deref for ${1:${VISUAL:Struct}} {
	    type Target = ${2:T};

	    fn deref(&self) -> &${2} {
	        ${0}
	    }
	}
snippet iter
	impl Iterator for ${1:${VISUAL:Struct}} {
	    type Item = ${2:T};

	    fn next(&mut self) -> Option<Self::Item> {
	        ${0}
	    }
	}
snippet into_iter
	impl IntoIterator for ${1:${VISUAL:Struct}} {
	    type Item = ${2:T};
	    type IntoIter = ${3:I};

	    fn into_iter(self) -> Self::IntoIter {
	        ${0}
	    }
	}
snippet for
	for ${1:i} in ${2} {
	    ${0:$VISUAL}
	}
snippet ifl
	if let Some(${1}) = ${2} {
	    ${0:$VISUAL}
	}
snippet whl
	while let Some(${1}) = ${2} {
	    ${0:$VISUAL}
	}
snippet spawn
	thread::spawn(${1}|| {
	    ${0:$VISUAL}
	});
snippet opt
	Option<${1:$VISUAL}>
snippet res
	Result<${1:$VISUAL}, ${2:Err}>
snippet vec
	vec![${1}]
snippet box
	Box::new(${0:$VISUAL})
snippet rc
	Rc::new(${0:$VISUAL})
snippet refc
	RefCell::new(${0:$VISUAL})
snippet mutex
	Mutex::new(${0:$VISUAL})
snippet arc
	Arc::new(${0:VISUAL})
snippet chan
	let (${1:tx}, ${2:rx}) = mpsc::channel();
snippet pr
	println!("${1}"${2});
snippet epr
	eprintln!("${1}"${2});
snippet fmt
	format!("${1}"${2})
snippet wr
	write!(${3:f}, "${1}"${2})
snippet dbg
	dbg!(${0:${VISUAL}})
snippet dump
	println!("{:#?}", ${1:$VISUAL});
snippet todo
	todo!()
snippet unimplemented
	unimplemented!()
snippet unreachable
	unreachable!()
snippet #[
	#[${1:derive(${2:Debug})}]
snippet cfg
	#[cfg(${1:target_os = "${2:linux}"})]
snippet main
	pub fn main() {
	    ${0:$VISUAL}
	}
snippet tests
	#[cfg(test)]
	mod tests {
	    use super::*;

	    ${0}
	}
snippet ut
	#[test]
	fn ${1:my_test}() {
	    ${0}
	}
snippet assert
	assert!(${1:true});
snippet eq
	assert_eq!(${1:lhs}, ${2:rhs});
snippet ne
	assert_ne!(${1:lhs}, ${2:rhs});
